const express = require('express');
const PipelineOrchestrator = require('../pipeline/orchestrator');

const router = express.Router();

// Initialize the pipeline orchestrator with API keys
const initializeOrchestrator = () => {
  const config = {
    gpt4ApiKey: process.env.GPT4_API_KEY || '',
    claude4ApiKey: process.env.CLAUDE4_API_KEY || '',
    geminiApiKey: process.env.GEMINI_API_KEY || '',
    deepseekApiKey: process.env.DEEPSEEK_API_KEY || '',
    gpt4oApiKey: process.env.GPT4O_API_KEY || ''
  };

  return new PipelineOrchestrator(config);
};

// Enhanced DSA problem solving endpoint
router.post('/solve-dsa', async (req, res) => {
  const { problem, language = 'cpp' } = req.body;

  if (!problem || !problem.description) {
    return res.status(400).json({ 
      error: 'Invalid problem provided',
      details: 'Problem must include description field'
    });
  }

  console.log('🎯 Enhanced DSA Problem Solving Request');
  console.log(`📝 Problem: ${problem.title || 'Untitled'}`);
  console.log(`🔧 Language: ${language}`);
  console.log(`📊 Difficulty: ${problem.difficulty || 'Unknown'}`);

  try {
    // Initialize the pipeline orchestrator
    const orchestrator = initializeOrchestrator();
    
    // Create comprehensive problem description
    const problemDescription = `
Problem Title: ${problem.title || 'Untitled Problem'}
Difficulty: ${problem.difficulty || 'Unknown'}
Category: ${problem.category || 'General'}

Problem Description:
${problem.description}

Constraints:
${problem.constraints ? problem.constraints.join('\n') : 'No specific constraints provided'}

Examples:
${problem.examples ? problem.examples.map(ex => `Input: ${ex.input}\nOutput: ${ex.output}`).join('\n\n') : 'No examples provided'}

Additional Information:
- Programming Language: ${language}
- Problem Type: DSA/Competitive Programming
- Target: Optimal solution with complexity analysis
`;

    // Execute the sequential AI pipeline
    const pipelineResults = await orchestrator.solveDSAProblem(problemDescription, language);

    // Format the response
    const response = {
      success: pipelineResults.success,
      metadata: {
        finalPhase: pipelineResults.finalPhase,
        totalExecutionTime: pipelineResults.totalExecutionTime,
        totalAttempts: pipelineResults.phases.length,
        phaseDetails: orchestrator.getPhaseDetails(pipelineResults.finalPhase)
      },
      solution: null,
      errorDetails: null
    };

    if (pipelineResults.success && pipelineResults.finalSolution) {
      // Extract solution components
      const rawCode = pipelineResults.finalSolution.code || '';
      const time = extractTimeComplexity(rawCode);
      const space = extractSpaceComplexity(rawCode);
      const approach = extractApproach(rawCode);
      const commentedCode = buildCommentedCode(rawCode, language, {
        title: problem.title || 'DSA Solution',
        approach,
        timeComplexity: time,
        spaceComplexity: space,
        notes: 'Auto-generated by Sequential AI Pipeline',
      });

      const solution = {
        code: commentedCode,
        language: language,
        timeComplexity: time,
        spaceComplexity: space,
        approach: approach,
        explanation: generateExplanation(pipelineResults, orchestrator),
        testCases: pipelineResults.finalSolution.testCases,
        testResults: {
          passed: pipelineResults.finalSolution.testResults.passedTests.length,
          failed: pipelineResults.finalSolution.testResults.failedTests.length,
          total: pipelineResults.finalSolution.testResults.totalTests,
          successRate: pipelineResults.finalSolution.testResults.totalTests > 0 ? 
            (pipelineResults.finalSolution.testResults.passedTests.length / pipelineResults.finalSolution.testResults.totalTests * 100).toFixed(1) : 0
        }
      };

      response.solution = solution;
    } else {
      // Try to provide the best-attempt code even if not all tests passed
      const candidatePhases = pipelineResults.phases.filter(p => p && p.code);
      if (candidatePhases.length > 0) {
        // Select the phase with the highest number of passed tests
        const bestPhase = candidatePhases.reduce((best, current) => {
          const bestPassed = best?.testResults?.passedTests?.length || 0;
          const currPassed = current?.testResults?.passedTests?.length || 0;
          return currPassed > bestPassed ? current : best;
        }, candidatePhases[0]);

        const rawCode = bestPhase.code || '';
        const time = extractTimeComplexity(rawCode);
        const space = extractSpaceComplexity(rawCode);
        const approach = extractApproach(rawCode);
        const commentedCode = buildCommentedCode(rawCode, language, {
          title: problem.title || 'DSA Solution (Best Attempt)',
          approach,
          timeComplexity: time,
          spaceComplexity: space,
          notes: 'Best attempt from failed pipeline; some tests may not pass',
        });

        response.success = true; // allow frontend to render the code
        response.solution = {
          code: commentedCode,
          language: language,
          timeComplexity: time,
          spaceComplexity: space,
          approach: approach,
          explanation: generateExplanation({
            ...pipelineResults,
            finalPhase: bestPhase.phase,
            finalSolution: {
              code: rawCode,
              testResults: bestPhase.testResults
            }
          }, orchestrator),
          testCases: bestPhase.testCases || [],
          testResults: {
            passed: bestPhase?.testResults?.passedTests?.length || 0,
            failed: bestPhase?.testResults?.failedTests?.length || 0,
            total: bestPhase?.testResults?.totalTests || 0,
            successRate: bestPhase?.testResults?.totalTests > 0 ?
              ((bestPhase.testResults.passedTests.length / bestPhase.testResults.totalTests) * 100).toFixed(1) : 0
          },
          partial: true
        };

        // Also include metadata from best phase
        response.metadata = {
          finalPhase: bestPhase.phase,
          totalExecutionTime: pipelineResults.totalExecutionTime,
          totalAttempts: pipelineResults.phases.length,
          phaseDetails: orchestrator.getPhaseDetails(bestPhase.phase),
          partial: true
        };
      } else {
        response.errorDetails = {
          message: 'All pipeline phases failed to find a solution',
          failedPhases: pipelineResults.phases.filter(p => !p.success).map(p => ({
            phase: p.phase,
            error: p.error,
            executionTime: p.executionTime
          })),
          lastError: pipelineResults.errorDetails
        };
      }
    }

    // Add detailed phase information
    response.phases = pipelineResults.phases.map(phase => ({
      phase: phase.phase,
      success: phase.success,
      executionTime: phase.executionTime,
      details: orchestrator.getPhaseDetails(phase.phase),
      error: phase.error || null
    }));

    console.log(`✅ Enhanced DSA solving completed in ${pipelineResults.totalExecutionTime}ms`);
    console.log(`🎯 Success: ${pipelineResults.success}, Final Phase: ${pipelineResults.finalPhase}`);

    res.json(response);

  } catch (error) {
    console.error('❌ Enhanced DSA solving failed:', error);
    res.status(500).json({ 
      error: 'Enhanced DSA problem solving failed',
      details: error.message,
      success: false
    });
  }
});

// Helper functions to extract solution components
function extractTimeComplexity(code) {
  const timeRegex = /time complexity[:\s]*O\([^)]+\)/i;
  const match = code.match(timeRegex);
  return match ? match[0].split(':')[1]?.trim() || 'O(n)' : 'O(n)';
}

function extractSpaceComplexity(code) {
  const spaceRegex = /space complexity[:\s]*O\([^)]+\)/i;
  const match = code.match(spaceRegex);
  return match ? match[0].split(':')[1]?.trim() || 'O(1)' : 'O(1)';
}

function extractApproach(code) {
  const approachRegex = /approach[:\s]*([^.\n]+)/i;
  const match = code.match(approachRegex);
  return match ? match[1].trim() : 'Algorithmic approach';
}

function generateExplanation(pipelineResults, orchestrator) {
  const phaseDetails = orchestrator.getPhaseDetails(pipelineResults.finalPhase);
  
  let explanation = `Solution found in Phase ${pipelineResults.finalPhase} using ${phaseDetails.models.join(' → ')}.\n\n`;
  explanation += `Pipeline Details:\n`;
  explanation += `- Total Execution Time: ${pipelineResults.totalExecutionTime}ms\n`;
  explanation += `- Total Attempts: ${pipelineResults.phases.length}\n`;
  const passed = pipelineResults.finalSolution?.testResults?.passedTests?.length || 0;
  const total = pipelineResults.finalSolution?.testResults?.totalTests || 0;
  const rate = total > 0 ? ((passed / total) * 100).toFixed(1) : '0.0';
  explanation += `- Success Rate: ${rate}%\n\n`;
  explanation += `Algorithm Approach: ${extractApproach(pipelineResults.finalSolution.code)}\n`;
  explanation += `Time Complexity: ${extractTimeComplexity(pipelineResults.finalSolution.code)}\n`;
  explanation += `Space Complexity: ${extractSpaceComplexity(pipelineResults.finalSolution.code)}`;

  return explanation;
}

// Build a language-appropriate comment header and prepend to code
function buildCommentedCode(code, language, meta) {
  const headerLines = [];
  if (meta.title) headerLines.push(`Title: ${meta.title}`);
  if (meta.approach) headerLines.push(`Approach: ${meta.approach}`);
  if (meta.timeComplexity) headerLines.push(`Time Complexity: ${meta.timeComplexity}`);
  if (meta.spaceComplexity) headerLines.push(`Space Complexity: ${meta.spaceComplexity}`);
  if (meta.notes) headerLines.push(`Notes: ${meta.notes}`);

  const headerText = headerLines.join('\n');

  switch ((language || '').toLowerCase()) {
    case 'python':
      return `"""
${headerText}
"""

${code}`;
    case 'java':
    case 'javascript':
    case 'cpp':
    case 'c++':
    default:
      return `/*
${headerText}
*/

${code}`;
  }
}

module.exports = router; 